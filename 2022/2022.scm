;;  Advent of Code 2022
;;

(define (day1-1 elf-counts)
  (let ((count-list (string-split elf-counts #\newline)))
    (let reduce ((to-count count-list) (max-elf 0) (current-elf 0))
      (if (null? to-count)
          (max max-elf current-elf)
          (let* ((current-count (car to-count))
                 (parsed (string->number current-count)))
            (cond ((= 0 (string-length current-count))
                   (reduce (cdr to-count) (max current-elf max-elf) 0))
                  (parsed (reduce (cdr to-count) max-elf (+ current-elf parsed)))
                  (#t (error (string-append "Unable to parse number: " current-count)))))))))

(define (day1-2 elf-counts)
  (let ((count-list (string-split elf-counts #\newline)))
    (let reduce ((to-count count-list) (elves '()) (current-elf 0))
      (if (null? to-count)
          (let* ((srtd (sort (cons current-elf elves) >=)))
            (apply + (list (car srtd) (list-ref srtd 1) (list-ref srtd 2))))
          (let* ((current-count (car to-count))
                 (parsed (string->number current-count)))
            (cond ((= 0 (string-length current-count))
                   (reduce (cdr to-count) (cons current-elf elves) 0))
                  (parsed (reduce (cdr to-count) elves (+ current-elf parsed)))
                  (#t (error (string-append "Unable to parse number: " current-count)))))))))

(define (day2-1 input)
  (define (parse-turn str)
    (list (string-ref str 0) (string-ref str 2)))
  (define (move->value char)
    ;;  A & X = 1, B & Y = 2, C & Z = 3
    (- (modulo (char->integer char) 23) 18))
  (define (outcome turn)
    ;;  0 on loss, 3 on draw, 6 on win
    (list-ref '(0 6 3 0 6)
              (+ 2 (- (car turn) (cadr turn)))))
  (define (sum-score to-count sum)
    (if (null? to-count)
        sum
        (let* ((this-turn-strings (car to-count))
               (this-turn (map move->value this-turn-strings))
               (my-move (cadr this-turn))
               (this-outcome (outcome this-turn)))
          (sum-score (cdr to-count) (+ sum my-move this-outcome)))))
  (let* ((turns (string-split input #\newline))
         (movelist (map parse-turn turns)))
    (sum-score movelist 0)))

(define (day2-2 input)
  (define (parse-turn str)
    (list (string-ref str 0) (string-ref str 2)))
  (define (move->value char)
    (- (modulo (char->integer char) 23) 18))
  (define (outcome turn)
    ;;  0 on loss, 3 on draw, 6 on win
    (list-ref '(0 6 3 0 6)
              (+ 2 (- (car turn) (cadr turn)))))
  (define (pick-move turn)
    (1+ (modulo (+ (car turn) (- (1- (cadr turn)) 2)) 3)))
  (define (sum-score to-count sum)
    (if (null? to-count)
        sum
        (let* ((this-turn-strings (car to-count))
               (this-turn (map move->value this-turn-strings))
               (my-move (pick-move this-turn))
               (this-outcome (outcome (list (car this-turn) my-move))))
          (sum-score (cdr to-count) (+ sum my-move this-outcome)))))
  (let* ((turns (string-split input #\newline))
         (movelist (map parse-turn turns)))
    (sum-score movelist 0)))

(define (day3-1 input)
  (define (find-match line)
    ;; Iter over first half, checking second half for occurrence
    (let* ((midpoint (/ (string-length line) 2))
           (half1 (substring line 0 midpoint))
           (half2 (substring line midpoint)))
      (let iter ((n 0))
        (when (>= n (string-length half1))
          (error "Match not found"))
        (if (string-index half2 (string-ref half1 n))
            (string-ref half1 n)
            (iter (1+ n))))))
  (define (score-char c)
    (if (char-upper-case? c)
        (- (char->integer c) 38)        ; Upper case
        (- (char->integer c) 96)))      ; Lower
  (define (match-and-score line)
    (score-char (find-match line)))
  (let ((rucksacks (string-split input #\newline)))
    (let reduce ((lines rucksacks) (sum 0))
      (if (null? lines)
          sum
          (reduce (cdr lines) (+ sum (match-and-score (car lines))))))))

(define (day3-2 input)
  (define (find-badge group)
    ;; For each char in the first line, check the 2nd and 3rd
    (let iter ((n 0))
      (when (>= n (string-length (car group)))
        (error "Badge not found"))
      (let* ((first (car group))
             (second (cadr group))
             (third (caddr group))
             (match-char (string-ref first n)))
        (if (and (string-index second match-char)
                 (string-index third match-char))
            match-char
            (iter (1+ n))))))
  (define (score-char c)
    (if (char-upper-case? c)
        (- (char->integer c) 38)
        (- (char->integer c) 96)))
  (let ((rucksacks (string-split input #\newline)))
    (let reduce ((lines rucksacks) (sum 0))
      (if (null? lines)
          sum
          (reduce (list-tail lines 3)
                  (+ sum (score-char (find-badge (list-head lines 3)))))))))

(define (day4-1 input)
  (define (check-overlap digits)
    ;; Find the larger segment, check containment
    (let* ((first (car digits))
           (second (cadr digits))
           (third (caddr digits))
           (fourth (cadddr digits)))
      (if (> (- second first)
             (- fourth third))
          (and (<= first third)
               (>= second fourth))
          (and (<= third first)
               (>= fourth second)))))
  ;; This could be done more efficiently, but done is better than polished
  (define (break-elfpair line)
    (string-split line (char-set #\, #\-)))
  (define (parse-broken pair)
    (map string->number pair))
  (let* ((lines (string-split input #\newline))
         (broken-out (map break-elfpair lines))
         (parsed (map parse-broken broken-out)))
    (length (filter check-overlap parsed))))

(define (day4-2 input)
  (define (check-overlap digits)
    (let* ((first (car digits))
           (second (cadr digits))
           (third (caddr digits))
           (fourth (cadddr digits)))
      (or (and (>= first third)
               (<= first fourth))
          (and (>= second third)
               (<= second fourth))
          (and (>= third first)
               (<= third second))
          (and (>= fourth first)
               (<= fourth second)))))
  (define (break-elfpair line)
    (string-split line (char-set #\, #\-)))
  (define (parse-broken pair)
    (map string->number pair))
  (let* ((lines (string-split input #\newline))
         (broken-out (map break-elfpair lines))
         (parsed (map parse-broken broken-out)))
    (length (filter check-overlap parsed))))
